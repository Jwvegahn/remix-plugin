pragma solidity >=0.6.0 <0.7.0;
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/token/ERC20/ERC20.sol";
contract CustomERC20 is ERC20 {
    event feeGenerated(uint);
    address baseAddress;
    uint rate;
    constructor (string memory name, string memory symbol) ERC20(name, symbol) public {
        baseAddress = msg.sender;
        rate = 5; // 5/100 
        _mint(msg.sender, 10000000);
    }
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        uint fee = (amount * rate) / 100;
        _transfer(_msgSender(), baseAddress, fee); // send fee
        emit feeGenerated(fee);
        super.transfer(recipient, amount);
        return true;
    }
}
const metadata = JSON.parse(await remix.call('fileManager', 'getFile', 'browser/artifacts/CustomERC20.json'))
    const accounts = await web3.eth.getAccounts()

    let contract = new web3.eth.Contract(metadata.abi)

    contract = contract.deploy({
      data: metadata.data.bytecode.object,
      arguments: ["Mask", "N95"]
    })

    newContractInstance = await contract.send({
      from: accounts[0],
      gas: 1500000,
      gasPrice: '30000000000'
    })
    console.log(newContractInstance.options.address)
  } catch (e) {
    console.log(e.message)
  }
})()
(async function() {
  try {
    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', 'browser/artifacts/CustomERC20.json'))
    // the variable web3Provider is a remix global variable object
    const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner()
    // Create an instance of a Contract Factory
    let factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer);
    // Notice we pass the constructor's parameters here
    let contract = await factory.deploy('Mask', 'N95');
    // The address the Contract WILL have once mined
    console.log(contract.address);
    // The transaction that was sent to the network to deploy the Contract
    console.log(contract.deployTransaction.hash);
    // The contract is NOT deployed yet; we must wait until it is mined
    await contract.deployed()
    // Done! The contract is deployed.
    console.log('contract deployed')
  } catch (e) {
    console.log(e.message)
  }
})();
